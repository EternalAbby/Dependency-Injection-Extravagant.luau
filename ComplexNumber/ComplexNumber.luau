--!strict

local TypeCheck = require(script.Parent.TypeCheck)

local module = {}

export type RawComplexNumber = {
	["real"]: number,
	["complex"]: number
}

export type ComplexNumber = setmetatable<{
	["real"]: number,
	["complex"]: number
}, typeof(module)>


local function CreateRawComplexNumber(real: number, complex: number): RawComplexNumber
	return {
		["real"] = real,
		["complex"] = complex
	}
end

local function GetNumberComponentTypes(candidate: ComplexNumber | number): (boolean, boolean)
	return TypeCheck.isNumber(candidate::number, false), TypeCheck.isComplexNumber(candidate::ComplexNumber)
end


-- ** CONSTRUCTORS ** --

--[[
Constructor: Creates a new <ComplexNumber> object from <real>, and <complex> (rectangular form).
Both parameters must be a <number> primitive type, and they must not be either inf or nan.
]]
module.new = function(real: number, complex: number): ComplexNumber
	assert(TypeCheck.isNumber(real, false), `Failed to construct a new <ComplexNumber> object. Expected number type for real part (arg #1), got {typeof(real)}.`)
	assert(TypeCheck.isNumber(complex, false), `Failed to construct a new <ComplexNumber> object. Expected number type for complex part (arg #2), got {typeof(complex)}.`)
	
	local new = CreateRawComplexNumber(real, complex)
	return setmetatable(new, module)
end

local complexUnit = module.new(0, 1)

--[[
Constructor: Creates a new <ComplexNumber> object from a valid <RawComplexNumber> type.
A valid <RawComplexNumber> type is a table with both a <real> key, and a <complex> key. Refer to type definitions in documentation for more details.
Both keys must be a <number> primitive type, and they must not be either inf or nan.
]]
module.fromRaw = function(raw: RawComplexNumber): ComplexNumber
	assert(TypeCheck.isComplexNumber(raw), `Failed to construct a new <ComplexNumber> object. Expected <RawComplexNumber> type (arg #1), got {typeof(raw)}`)
	
	local new = CreateRawComplexNumber(raw.real, raw.complex)
	return setmetatable(new, module)
end

--[[
Constructor: Creates a new <ComplexNumber> object from <magnitude>, and <argument> (in radians) (polar form).
Both parameters must be a <number> primitive type, and they must not be either inf or nan.
]]
module.fromPolar = function(magnitude: number, argument: number): ComplexNumber
	assert(TypeCheck.isNumber(magnitude, false), `Failed to construct a new <ComplexNumber> object. Expected number primitive type (arg #1), got {typeof(magnitude)}`)
	assert(TypeCheck.isNumber(argument, false), `Failed to construct a new <ComplexNumber> object. Expected number primitive type (arg #1), got {typeof(argument)}`)
	
	local real = magnitude * math.cos(argument)
	local complex = magnitude * math.sin(argument)
	
	local new = CreateRawComplexNumber(real, complex)
	return setmetatable(new, module)
end

-- ** FUNCTIONS ** --

--[[
Function: Computes the trigonometric function `cis(theta)` with angle <theta> (in radians).
Equivalent to computing 'cos(theta) + ùíä sin(theta)', or Euler's formula.
]]
module.cis = function(theta: number): ComplexNumber
	assert(TypeCheck.isNumber(theta, false), `Failed to compute \`cis()\` trig function. Expected number type (arg #1), got {typeof(theta)}`)
	
	local cosine = math.cos(theta)
	local sine = math.sin(theta) * complexUnit
	return cosine + sine
end


-- ** METHODS ** --

-- Method: Creates a new <ComplexNumber> object, whose real, and imaginary parts are from <self>.
module.clone = function(self: ComplexNumber): ComplexNumber
	return module.new(self.real, self.complex)
end

--[[
Method: Computes the modulus (magnitude, or absolute value) of <self>, the <ComplexNumber> object which called this method.
Similarly, using # operator on a <ComplexNumber> object returns this result.
]]
module.magnitude = function(self: ComplexNumber): number
	return math.sqrt(self.real^2 + self.complex^2)
end

-- Method: Computes the complex argument (counter-clockwise angle from the positive real axis) of <self>, the <ComplexNumber> object which called this method.
module.argument = function(self: ComplexNumber): number
	return math.atan2(self.complex, self.real)
end

-- Method: Creates a new <ComplexNumber> object that is the complex conjugate of <self>, the <ComplexNumber> object which called this method.
module.conjugate = function(self: ComplexNumber): ComplexNumber
	return module.new(self.real, -self.complex)
end

-- Method: Returns both the magnitude, and the complex argument of <self>, the <ComplexNumber> object which called this method.
module.polar = function(self: ComplexNumber): (number, number)
	local r = self:magnitude()
	local phi = self:argument()
	return r, phi
end


-- ** METAMETHODS ** --

module.__index = module

module.__newindex = function()
	error("Attempted to create a new key/index in a <ComplexNumber> object.")
end

module.__metatable = "ComplexNumber"


module.__add = function(a: ComplexNumber | number, b: ComplexNumber | number): ComplexNumber
	local isnum_A, iscomplex_A = GetNumberComponentTypes(a)
	local isnum_B, iscomplex_B = GetNumberComponentTypes(b)
	
	assert(isnum_A or iscomplex_A)
	assert(isnum_B or iscomplex_B)
	
	if isnum_A then
		a = CreateRawComplexNumber(a::number, 0) :: ComplexNumber
	elseif isnum_B then
		b = CreateRawComplexNumber(b::number, 0) :: ComplexNumber
	end
	
	a = a :: ComplexNumber
	b = b :: ComplexNumber
	
	local real = a.real + b.real
	local complex = a.complex + b.complex
	
	local new = module.new(real, complex)
	return new
end

module.__sub = function(a: ComplexNumber | number, b: ComplexNumber | number): ComplexNumber
	local isnum_A, iscomplex_A = GetNumberComponentTypes(a)
	local isnum_B, iscomplex_B = GetNumberComponentTypes(b)
	
	assert(isnum_A or iscomplex_A)
	assert(isnum_B or iscomplex_B)
	
	if isnum_A then
		a = CreateRawComplexNumber(a::number, 0) :: ComplexNumber
	elseif isnum_B then
		b = CreateRawComplexNumber(b::number, 0) :: ComplexNumber
	end
	
	a = a :: ComplexNumber
	b = b :: ComplexNumber
	
	local real = a.real - b.real
	local complex = b.real - b.complex
	
	local new = module.new(real, complex)
	return new
end

module.__mul = function(a: ComplexNumber | number, b: ComplexNumber | number): ComplexNumber
	local isnum_A, iscomplex_A = GetNumberComponentTypes(a)
	local isnum_B, iscomplex_B = GetNumberComponentTypes(b)
	
	assert(isnum_A or iscomplex_A)
	assert(isnum_B or iscomplex_B)
	
	if isnum_A then
		a = CreateRawComplexNumber(a::number, 0) :: ComplexNumber
	elseif isnum_B then
		b = CreateRawComplexNumber(b::number, 0) :: ComplexNumber
	end
	
	a = a :: ComplexNumber
	b = b :: ComplexNumber
	
	local real = a.real * b.real - a.complex * b.complex
	local complex = a.real * b.complex + a.complex * b.real
	
	local new = module.new(real, complex)
	return new
end

module.__div = function(a: ComplexNumber | number, b: ComplexNumber | number): ComplexNumber
	local isnum_A, iscomplex_A = GetNumberComponentTypes(a)
	local isnum_B, iscomplex_B = GetNumberComponentTypes(b)
	
	assert(isnum_A or iscomplex_A)
	assert(isnum_B or iscomplex_B)
	
	if isnum_A then
		a = CreateRawComplexNumber(a::number, 0) :: ComplexNumber
	elseif isnum_B then
		b = CreateRawComplexNumber(b::number, 0) :: ComplexNumber
	end
	
	a = a :: ComplexNumber
	b = b :: ComplexNumber
	
	assert(b.real ~= 0 and b.complex ~= 0, "Attempted to perform division by zero.")
	
	local real_numerator = a.real * b.real + a.complex * b.complex
	local complex_numerator = a.complex * b.real - a.real * b.complex
	local denominator = b.real^2 + b.complex^2
	
	local real = real_numerator / denominator
	local complex = complex_numerator / denominator
	
	local new = module.new(real, complex)
	return new
end

module.__idiv = function(a: ComplexNumber | number, b: ComplexNumber | number): ComplexNumber
	a = a :: ComplexNumber
	b = b :: ComplexNumber
	
	local res = a / b
	res.real = math.floor(res.real)
	res.complex = math.floor(res.complex)
	return res
end

module.__mod = function(a: ComplexNumber | number, b: ComplexNumber | number): nil
	error("This is an invalid operation as of now.")
end

module.__pow = function(a: ComplexNumber | number, b: ComplexNumber | number): ComplexNumber
	local isnum_A, iscomplex_A = GetNumberComponentTypes(a)
	local isnum_B, iscomplex_B = GetNumberComponentTypes(b)
	
	assert(isnum_A or iscomplex_A)
	assert(isnum_B or iscomplex_B)
	
	if isnum_A then
		a = CreateRawComplexNumber(a::number, 0) :: ComplexNumber
	elseif isnum_B then
		b = CreateRawComplexNumber(b::number, 0) :: ComplexNumber
	end
	
	a = a :: ComplexNumber
	b = b :: ComplexNumber
	
	-- edge case: 0 ^ complex
	if a.real == 0 and a.complex == 0 then
		
		-- case: 0 ^ 0
		if b.real == 0 and b.complex == 0 then
			return module.new(1, 0)
			
		-- case: 0 ^ (purely-complex)
		elseif b.real == 0 and b.complex ~= 0 then
			error(`Undefined limit behavior for purely imaginary exponent.`)
			
		-- case: 0 ^ +real
		elseif b.real > 0 then
			return module.new(0, 0)
			
		-- case: 0 ^ -real
		elseif b.real < 0 then
			error(`Attempted to perform division by zero.`)
		end
		
	-- simple case: complex ^ 0
	elseif b.real == 0 and b.complex == 0 then
		return module.new(1, 0)
		
	-- simple case: real ^ real
	elseif a.complex == 0 and b.complex == 0 then
		return module.new(a.real ^ b.real, 0)
	end
	
	-- main case: complex ^ complex
	local base_magnitude_squared = a.real^2 + a.complex^2
	local base_argument = a:argument()
	
	local term_1 = base_magnitude_squared ^ (b.real / 2)
	local term_2 = math.exp(-b.complex * base_argument)
	local term_3 = module.cis(b.real * base_argument + b.complex * math.log(base_magnitude_squared) / 2)
	return term_1 * term_2 * term_3
end


module.__eq = function(a: ComplexNumber, b: ComplexNumber): boolean
	local magnitude_A = a:magnitude()
	local magnitude_B = b:magnitude()
	return magnitude_A == magnitude_B
end

module.__lt = function(a: ComplexNumber, b: ComplexNumber): boolean
	local magnitude_A = a:magnitude()
	local magnitude_B = b:magnitude()
	return magnitude_A < magnitude_B
end

module.__le = function(a: ComplexNumber, b: ComplexNumber): boolean
	local magnitude_A = a:magnitude()
	local magnitude_B = b:magnitude()
	return magnitude_A <= magnitude_B
end


module.__len = function(self: ComplexNumber): number
	return self:magnitude()
end

module.__unm = function(a: ComplexNumber): ComplexNumber
	a.real = a.real * -1
	a.complex = a.complex * -1
	return a
end

local meta_tostring_signs = {"-", "+", "+"}
module.__tostring = function(self: ComplexNumber): string
	local complex_sign = meta_tostring_signs[math.sign(self.complex) + 2]
	local complex_number = math.abs(self.complex)
	
	return `({self.real} {complex_sign} {complex_number}ùíä)`
end

return module::typeof(module)
